### 获取数据
API layer  

使用场景：  
需要使用提供API的第三方库  
从客户端获取数据：需要在服务器上运行一个API层  

可以使用Route Handler创建API  

数据库查询  

使用场景：  
创建API时，需要编写逻辑与数据库交互  
如果使用RSC（服务端组件），可以跳过API层，直接查询数据库  

data.js中直接定义了SQL查询接口，await调用即可从数据库获取数据  
page页获取数据，传入组件渲染  
问题：数据请求相互阻塞，产生请求瀑布；  
next默认预渲染路由（静态渲染），如果数据改变，不会反映到页面上；  

请求瀑布：  
一系列网络请求，依赖于先前请求的完成情况，影响性能  
可以使用promise.all()并行启动所有数据请求  
如果一个请求比其他请求慢呢？  

### 静态和动态渲染
静态渲染：数据获取和渲染在构建时/重新验证数据时在服务器上进行  
动态渲染：内容会在请求时（用户访问页面时）在服务器上进行渲染  

动态渲染中，程序速度取决于最慢的数据获取请求  

### 流streaming
流是一种数据传输技术，允许服务器在响应发送之前先发送部分响应，从而提高响应速度  

整个页面：使用loading.tsx  streaming整个页面  
静态组件会立即显示，动态组件会等待数据获取完成后再显示  
return 出占位内容
```tsx
export default function Loading() {
    return <DashboardSkeleton />;
}
```
注意：loading目录层级较高，会作用于其他子页面，使用路由组限制作用范围  

组件：使用suspense包裹动态组件，可以实现流式渲染  
suspense:推迟渲染，直到满足某些条件（数据获取完成）fallback为占位内容    
```tsx
<Suspense fallback={<RevenueChartSkeleton />}>
    <RevenueChart/> 
</Suspense>
```
用cardWrapper包裹card组件，再使用Suspense包裹cardWrapper，同时加载多个组件  

### 部分预渲染PPR 
使用sespense包裹动态组件，可以实现部分预渲染  
sespense不会将组件本身变成动态，而是作为动态与静态代码的边界  
```tsx
const nextConfig: NextConfig = {
  experimental: {
    ppr: "incremental",
  },
};
```
```tsx
export const experimental_ppr = true;
```

### 搜索分页
搜索 使用URL搜索参数管理搜索状态  
1、捕获用户输入  
onChange={(event)=>handleSearch(event.target.value)}
2、使用searchParams更新URL  
3、将URL显示到input（同步）
```tsx
export default function Search({ placeholder }: { placeholder: string }) {
  const searchParams = useSearchParams();
  //获取当前路径
  const pathname=usePathname();
  //replace函数切换路由
  const {replace}=useRouter();
  
  const handleSearch=(term:string)=>{
    //创建一个新的params对象
    const params=new URLSearchParams(searchParams);
    //更新params
    //{query:term}
    if(term){
      params.set('query',term);
    }else{
      params.delete('query');
    }
    //切换路由，params.toString将参数转为URL友好格式
    replace(`${pathname}?${params.toString()}`);
  }
  return (
    <div className="relative flex flex-1 flex-shrink-0">
      <label htmlFor="search" className="sr-only">
        Search
      </label>
      <input
        className="peer block w-full rounded-md border border-gray-200 py-[9px] pl-10 text-sm outline-2 placeholder:text-gray-500"
        placeholder={placeholder}
        onChange={(event)=>handleSearch(event.target.value)}
        defaultValue={searchParams.get('query')?.toString()}
      />
      <MagnifyingGlassIcon className="absolute left-3 top-1/2 h-[18px] w-[18px] -translate-y-1/2 text-gray-500 peer-focus:text-gray-900" />
    </div>
  );
}
```
渲染  
page组件有默认参数，可以用来获取searchParams  
参数都是promise对象，需要await获取  
```tsx
// 页面组件的默认参数结构
export default async function Page({
  params,        // 路由参数 (如 [id])
  searchParams,  // URL 查询参数 (?query=value)
}: {
  params: Promise<{ [key: string]: string }>;
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
}) {
  // 使用参数
}
```
对于客户端组件，使用useSearchParams钩子获取searchParams  
对于服务端组件，可以page组件的默认参数获取searchParams，再传入组件渲染  

防抖  
使用useDebouncedCallback钩子  

分页  
使用Pagination组件，是客户端组件，所以不想在上面获取数据（项目没有用API层）  
所以使用page组件获取数据，再传入Pagination组件渲染  
切换page时更新URL，用useSearchParams等钩子获取当前状态  

###操作数据
Server Actions 服务器操作  
例如：在form中的action属性中使用，自动接收FormData对象，返回值会自动被包裹在useActionState钩子中  
```tsx
// Server Component
export default function Page() {
  // Action
  async function create(formData: FormData) {
    'use server';
 
    // Logic to mutate data...
  }
 
  // Invoke the action using the "action" attribute
  return <form action={create}>...</form>;
}
```
渐进式增强，js未加载也可以使用表单  
server action不仅可以用来修改数据，可以使用revalidatePath函数重新验证关联的缓存  

新建action.js文件 'use server'  
集中管理action，使用export导出  
在form组件中：
```tsx
import { createInvoice } from '@/app/lib/actions';
form action={createInvoice}
```

使用zod库处理类型验证  
```tsx
'use server';

const sql = postgres(process.env.POSTGRES_URL!, { ssl: 'require' });
//定义表单结构schema
const FormSchema = z.object({
    id: z.string(),
    customerId: z.string(),
    amount: z.coerce.number(),
    status: z.enum(['pending', 'paid']),
    date: z.string(),
  });

//创建一个schema，去掉id和date字段
const CreateInvoice = FormSchema.omit({id:true,date:true});

//插入数据
export async function createInvoice(formData:FormData){
    //使用schema验证表单数据
    const {customerId,amount,status}=CreateInvoice.parse({
        customerId:formData.get('customerId'),
        amount:formData.get('amount'),
        status:formData.get('status'),
    });
    //修改数据格式
    const amountInCents = amount * 100;
    const date = new Date().toISOString().split('T')[0];

    //插入数据
    await sql`INSERT INTO invoices (customer_id, amount, status, date) VALUES (${customerId}, ${amountInCents}, ${status}, ${date})`;
    //清除客户端路由缓存
    revalidatePath('/dashboard/invoices');
    //重定向回页面
    redirect('/dashboard/invoices');
}
//更新数据
const UpdateInvoice = FormSchema.omit({id:true,date:true});
//根据id更新数据,id使用js绑定
export async function updateInvoice(id:string,formData:FormData){
    //使用schema验证表单数据
    const {customerId,amount,status}=UpdateInvoice.parse({
        customerId:formData.get('customerId'),
        amount:formData.get('amount'),
        status:formData.get('status'),
    });
    //修改数据格式
    const amountInCents = amount * 100;
    //更新数据
    await sql`UPDATE invoices SET customer_id = ${customerId}, amount = ${amountInCents}, status = ${status} WHERE id = ${id}`;
    //清除客户端路由缓存
    revalidatePath('/dashboard/invoices');
    //重定向回页面
    redirect('/dashboard/invoices');
}
//删除数据
export async function deleteInvoice(id:string){
    //删除数据
    await sql`DELETE FROM invoices WHERE id = ${id}`;
    //清除客户端路由缓存
    revalidatePath('/dashboard/invoices');
}
```
```tsx
//使用js绑定id
const updateInvoiceWithId = updateInvoice.bind(null, invoice.id);git clone http://gitlab.synergylab.info:30000/qim/pythia.git
```






